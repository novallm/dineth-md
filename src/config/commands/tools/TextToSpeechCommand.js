const Command = require('../../structures/Command');
const gtts = require('node-gtts');
const path = require('path');
const fs = require('fs').promises;

class TextToSpeechCommand extends Command {
    constructor() {
        super({
            name: 'tts',
            aliases: ['say', 'speak'],
            description: 'Convert text to speech',
            category: 'tools',
            usage: '.tts <lang> <text>'
        });
    }

    async execute(message, args) {
        if (args.length < 2) {
            return message.reply(`‚ï≠‚îÄ‚ùí „Äé TEXT TO SPEECH „Äè ‚ùí
‚îÇ
‚îú‚îÄ‚ùí üó£Ô∏è *Usage:*
‚îÇ .tts <lang> <text>
‚îÇ
‚îú‚îÄ‚ùí üìù *Example:*
‚îÇ .tts en Hello World
‚îÇ
‚îú‚îÄ‚ùí üåê *Languages:*
‚îÇ ‚Ä¢ en - English
‚îÇ ‚Ä¢ si - Sinhala
‚îÇ ‚Ä¢ ta - Tamil
‚îÇ ‚Ä¢ hi - Hindi
‚îÇ ‚Ä¢ ja - Japanese
‚îÇ
‚îú‚îÄ‚ùí ‚ú® *Powered by:* Dineth MD
‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùí`);
        }

        const lang = args[0];
        const text = args.slice(1).join(' ');
        const outputPath = path.join(__dirname, `../../../temp/${Date.now()}.mp3`);

        try {
            await message.reply('üéØ *Generating audio...*');
            
            await new Promise((resolve, reject) => {
                const tts = gtts(lang);
                tts.save(outputPath, text, (err) => {
                    if (err) reject(err);
                    else resolve();
                });
            });

            await message.client.sendMessage(message.key.remoteJid, {
                audio: { url: outputPath },
                mimetype: 'audio/mp4',
                ptt: true,
                caption: '‚ú® Generated by Dineth MD'
            });

            await fs.unlink(outputPath);

        } catch (error) {
            console.error('TTS error:', error);
            message.reply('‚ùå Failed to generate speech.');
        }
    }
}

module.exports = TextToSpeechCommand; 